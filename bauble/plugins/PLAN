Plan plugin system

Order of operations:
1. Load plugins 
2. Init plugins


What it should do?

*** I've run into a problem I don't yet know the answer to. The registry will 
only be valid for a specific connection so we would need a connection specific
registry. Also what if the registry gets corrupted then we won't know what's
the status of the database if we connect to it again or someone else connects
to it. It sounds like we'll have to keep the registry data in the database 
itself. Maybe we can pickle the registry object right into the database in
the Bauble meta table. Or we could keep the registry in an XML file and pickle
that into the database.

The registry can only hold the classes and version of the classes that this
database was created with, anything like 'enabled' would have to either go
into the plugins themselves or into a separate global, file base registry.
		
*** What about using something like pydispatcher (pydispatcher.sourceforge.net)
to control registration and then theoretically all we would have to do is
check that in the end all the plugins got their signals that their dependencies
were met and then they were initialized as well....if in the end something
didn't get initialized we could give an error with the plugin that wasn't
initialized and check which if it's dependencies wasn't met
1. for each dependency in a plugins dependency list add a listener for that
dependencies actions, the actions should be pre-defined like, 
initialized, created, disabled, enabled, removed, registered...basically if a dependency is only the plugin name then
the plugin should listen to any signals that match from that plugin or the plugin
could just listen to specific signals
2. there will always be a default handler for an action and well known signals
but allow plugins to provide custom handlers for specific signals


-

Registration
-------------
- see the plugin/RegistryEntry class
- Use anydbm to create a plugin registry with names and version in name-version
format, the other option is to pickle plugins or plugin registry objects, also
see shelf to pickle objects to a db, this could be useful for recalling plugin
registry data by plugin name...shelve seems like the best fit
- If a plugin is removed then it should be unregistered from the registry
- Removing a plugin shouldn't remove the plugins table, there should be
a way to completely remove a plugin, data and all, possible have the 
plugin provide an uninstall method
- is it possible to serialize arbitrary python code in a db or something 
similar that could be called when a plugin is removed
- need to be careful with conflicts on plugin installation, if a plugin is 
trying to create a table that already exists in the database then this could
overwrite data
- should lock the registry so that only one instance of Bauble can access it at
a time....if we don't lock it we would have to keep all the registry data in 
memory....if we only use the registry data at startup that would be ok but that
wouldn't let us change the state of the registry during runtime...to do
locking we could create a .lock file in the users directory, if bauble is started
and there's already a lock file then we should ask the user what to do

- What is the order for init/registration
1. open the registry, check and act on plugins that were found possibly removing
them from the registry, if they aren't found then we should probably just
set them as disabled instead of removing them
1. initialize everything
2. check if anything is in the create queue and do creations,  creations
should be done in dependency sort order


Dependency
----------
- Intialization should NOT be dependent on order of initialization
- Plugin creation should be dependent on order
- Available plugins should be disabled if they're dependencies are not met

- allow GPG signed plugins

- The plugin directory should be customizable

- Dropping a package in the plugin directory should check if the package exposes
nd implementation of the Plugin interface, or maybe a list of classes that
expose Plugin


- should plugins have a "type" maybe if we have a more specific interface 
wrap the generic plugin interface we would know the type of plugin, say the
ToolPlugin interface wraps plugin interface so we know to add the ToolPlugin
to the tool menu, could also use this to create a FormatterPlugin

- should be able to delete the plugins directory and still have the Bauble
start correctly, this means we need to change the way the plugins are started
so we should remove __init__.py from plugins/....at least there should
be a message that says bauble can't be started because it can't find
the plugins directory or there are not plugin available

- after checking all the plugins we should check each plugins list of 
dependencies and make sure that can we loaded, if not we should present an
error and list the names of the plugins that could be loaded an why they 
couldn't, could control this with a PluginDependencyError exception

- it would probably be easier if plugins depended only on plugins and not things
like tables and other crap

- don't need tables b/c the are now included in sqlalchemy.default_metadata

- each module should be able to provide more than one plugin, i prefer that the
module expose a 'plugins' variable instead of each one calling register plugin,
though this doesn't really matter since each module has to be loaded any way to
check if it has a plugin variable...we should check if we can load a module with
executing in and just check if something is available without running the code,
most likely this isn't possible

- allow modules to be in zip files

- how should we build the insert menu, should we have a EditorPlugin class
that provides an editor and we then know that it should go in the insert menu

- need a way to add tables to the database base without creating a new
database completely, in case someone drops in a plugin we can create the 
needed tables

- need to be able to check if this is the plugins first run, might have to keep 
a plugin registry so we know what been initialized and what hasn't, probably
have to have a setup or create method for newly created plugins
- and what about a path for upgrading tables from one version of a plugin
to the next, versioning makes things start to get really complicated, **SQLite
doesn't allow column drop and alter, see http://erosson.com/migrate/docs/index.html
- allow plugin versioning and allow plugins to depends on specific version
of other plugins
- ability to customize the plugin directory, maybe we could set this in the 
config file with a default location if that fails

Documentation
-------------
- need to write a document on how to create new plugins
- about plugin versioning


	
	
	
